import { IAvailableDie, IDiceRoll, IDieType, IEngineConfig, IRoll, ITheme, ThemeName } from '@dice/config';
import { IApiResponse, RollEventCallback, RoomEventCallback, ThreeDDiceAPI, ThreeDDiceRollEvent, ThreeDDiceRoomEvent } from '@dice/api';
export declare enum ThreeDDiceDieEvent {
    AddDie = "addDie"
}
export declare class ThreeDDice {
    static DICE_ON_TABLE_LIMIT: number;
    static DefaultConfig: IEngineConfig;
    api?: ThreeDDiceAPI;
    private _autoRotateEnabled;
    private _controlsEnabled;
    private _isDiceThrowing;
    private _lastRotation;
    private _lastTime;
    private _pointerDown;
    private _pointerDownPosition;
    private _previewMode;
    private apiKey?;
    private audioListener;
    private camera?;
    private canvas?;
    private clock;
    private composer?;
    private config;
    private controls;
    private dice;
    private events;
    private highlightPass;
    private loader;
    private meshes;
    private outlinePasses;
    private physics;
    private pointer;
    private raycaster;
    private renderer;
    private rollQueue;
    private scene;
    private shaderMaterials;
    private sounds;
    private stats?;
    private textures;
    private themePreviewFetchQueue;
    private themes;
    constructor(canvas?: HTMLCanvasElement, apiKey?: string, config?: Partial<IEngineConfig>);
    static isWebGLAvailable: () => boolean;
    get autoRotate(): boolean;
    set autoRotate(enabled: boolean);
    get controlsEnabled(): boolean;
    set controlsEnabled(enabled: boolean);
    get height(): number;
    get isDiceThrowing(): boolean;
    get previewMode(): boolean;
    set previewMode(previewMode: boolean);
    get version(): string;
    get width(): number;
    clear: () => void;
    connect: (roomSlug: string, roomPasscode?: string, apiKey?: string) => ThreeDDice;
    getTheme: (themeId: ThemeName) => ITheme;
    getThemes: () => ITheme[];
    initialize(canvas?: HTMLCanvasElement, apiKey?: string, config?: Partial<IEngineConfig>): this;
    loadTheme: (theme: ITheme, overwriteTheme?: boolean, fetchPreviews?: boolean) => void;
    off(event: ThreeDDiceRollEvent | ThreeDDiceRoomEvent): ThreeDDice;
    on(event: ThreeDDiceRoomEvent, callback: RoomEventCallback): ThreeDDice;
    on(event: ThreeDDiceRollEvent, callback: RollEventCallback): ThreeDDice;
    pause: () => void;
    pickUpRoll: (roll: IRoll | IRoll[], uuids?: string[]) => Promise<IApiResponse<"roll[]", IRoll[]>>;
    preview: (theme: ITheme, availableDie: IAvailableDie | IDieType) => Promise<void>;
    resetCamera: () => void;
    resize: (width: number, height: number) => ThreeDDice;
    resume: () => void;
    roll: (dice: IDiceRoll[]) => Promise<IApiResponse<'roll', IRoll>>;
    screenshot: (mimeType: string) => string;
    setConfig: (config: Partial<IEngineConfig>) => void;
    start: () => ThreeDDice;
    unhideRoll(roll: IRoll, uuids?: string[]): Promise<IApiResponse<"roll", IRoll>>;
    private boardHeight;
    private boardWidth;
    private callAction;
    private createDie;
    private eventRollCreated;
    private eventRollUpdated;
    private eventRoomUpdated;
    private executeRoll;
    private fadeOutDiceByUuid;
    private getDiceOptions;
    private getThemeOptions;
    private highlightObjects;
    private initAudioListener;
    private initCamera;
    private initControls;
    private initPhysics;
    private initRenderer;
    private initScene;
    private initStats;
    private initWindowListeners;
    private isAppVisible;
    private isThemeLoaded;
    private listen;
    private loadMesh;
    private loadShaderMaterial;
    private loadSound;
    private loadTexture;
    private onPointerDown;
    private onPointerMove;
    private onPointerUp;
    private processQueueRoll;
    private queueRoll;
    private removeDiceByUuid;
    private removeDiceIfOverLimit;
    private removeDieByUuid;
    private unhideDiceByUuid;
    private unloadShaderMaterial;
    private unloadTheme;
    private update;
    private updateBoardSize;
}
